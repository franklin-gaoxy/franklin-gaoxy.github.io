
#### 递归
```shell
#!/bin/bash

symbol="    "
# $1 占位符号 $2 目录路径
function list(){
    echo "$1$2"
    for i in `ls ${2}`;do
        # 判断是否为文件
        if [ -f "$2/$i" ];then
            echo "${1}${symbol}${i}"
        else
            list "${1}${symbol}" "${2}/${i}"
        fi
    done
}
list "${symbol}" "/usr"

```
#### 格式化输出时间
```shell
echo "[`date +%F_%T`]: ${content}"
```
#### 缩写语法
```shell
cp myapp{,-bak}
```
#### 判断字符串
```shell
if [[ "x$1" == "xaaa" ]];then
	echo "yes!"
fi
```
#### 多线程
```shell
#!/bin/bash
vars()
{
    # 此函数定义了全局变量
    # 每次执行的最大进程数
    pool_number='5'
    # 总共循环次数
    process_sum_num='5'
}

process()
{
    # 此函数为后台执行函数
    echo "后台进程 $1"
    ssh es${1} "sleep 10"
    if [ $? -eq 0 ];then
        echo "后台进程 $1 [SUCESS]"
    else
        echo "后台进程 $1 [ERROR]"
    fi
}
pool()
{
    # 此函数为循环提交任务
    process_number=0
    for i in `seq $process_sum_num`;do
        process $i &
        process_number=$(($process_number + 1))
        # 判断当前提交的进程数是否到达了全局变量中定义的每次执行的最大数量
        if [[ $(($process_number % $pool_number)) == 0 ]];then
            # 如果已经满足了最大进程数 那么则执行等待 等待所有进程执行完毕才会开始新一轮的循环
            wait
        fi
    done
    sleep 0.5;echo "process running sucess."
}
start()
{
    vars
    pool
}
start

```
#### if操作
> -f 判断是否为文件
> -d 判断是否为目录
> && 且
> || 或

#### 脚本退出前 执行指定函数
```shell
#!/bin/bash

# 定义退出时需要执行的函数
function exit_func(){
    echo "Execute program exit cleanup function."
}
# 捕获exit信号 执行对应函数
trap exit_func EXIT

echo "Program startup!"
echo "Start processing tasks ..."
exit 1
echo "Program Exit"
```
> trap实际是用来捕获对应信号 可以执行对应函数或者代码的。

