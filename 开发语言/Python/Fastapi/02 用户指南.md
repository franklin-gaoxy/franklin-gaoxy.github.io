# 请求体
## 请求体与多个参数
### 多个请求体参数
```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


class User(BaseModel):
    username: str
    full_name: Union[str, None] = None


@app.put("/user/{user_id}")
async def update_item(user_id: int, item: Item, user: User):
    # 接收两个json结构体
    results = {"item_id": user_id, "item": item, "user": user}
    return results

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app,host="0.0.0.0",port=8000)
```
发起请求
```shell
curl -X 'PUT' \
  'http://127.0.0.1:8000/user/100' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "item": {
    "name": "zhangsan",
    "description": "",
    "price": 10,
    "tax": 20
  },
  "user": {
    "username": "cuihua",
    "full_name": "cui"
  }
}'
```
请求体:
```shell
{
  "item_id": 100,
  "item": {
    "name": "zhangsan",
    "description": "",
    "price": 10,
    "tax": 20
  },
  "user": {
    "username": "cuihua",
    "full_name": "cui"
  }
}
```
### 嵌入一个单个的值
```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


class User(BaseModel):
    username: str
    full_name: Union[str, None] = None


@app.put("/user/{user_id}")
async def update_item(user_id: int, item: Item, user: User,body :int):
    # 接收两个json结构体 同时需要一个单个的值 body int类型
    results = {"item_id": user_id, "item": item, "user": user,"body": body}
    return results

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app,host="0.0.0.0",port=8000)
```
请求
```shell
curl -X 'PUT' \
  'http://127.0.0.1:8000/user/100?body=23' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "item": {
    "name": "zhang san",
    "description": "hahahaha",
    "price": 10,
    "tax": 20
  },
  "user": {
    "username": "zhang",
    "full_name": "san"
  }
}'
```
请求体
```shell
{
  "item_id": 100,
  "item": {
    "name": "zhang san",
    "description": "hahahaha",
    "price": 10,
    "tax": 20
  },
  "user": {
    "username": "zhang",
    "full_name": "san"
  },
  "body": 23
}
```
## 嵌套模型
```python
from typing import Union,List,Set

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class capacity(BaseModel):
    capacity: List[str]
class Item(BaseModel):
    name: str
    age : int
    # 两种声明的都是 list 类型 也可以不加后面的 =[] 如上
    address : List[str] = []
    tag : Set[str] = set()
    # 嵌套了另一个json 由上面的capacity定义
    capacity: capacity

@app.put("/user/{user_id}")
async def update_item(user_id: int, item: Item):
    # 接收两个json结构体
    results = {"item_id": user_id, "item": item}
    return results

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app,host="0.0.0.0",port=8000)
```
请求
```shell
curl -X 'PUT' \
  'http://127.0.0.1:8000/user/111' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "name": "zhang san",
  "age": 30,
  "address": ["beijing","tianjin"],
  "tag": ["zhonglaonian","weihun"],
  "capacity": {
    "capacity": [
      "write code","eat","xuxu"
    ]
  }
}'
```
相应
```shell
{
  "item_id": 111,
  "item": {
    "name": "zhang san",
    "age": 30,
    "address": [
      "beijing",
      "tianjin"
    ],
    "tag": [
      "zhonglaonian",
      "weihun"
    ],
    "capacity": {
      "capacity": [
        "write code",
        "eat",
        "xuxu"
      ]
    }
  }
}
```
### 带有一组子模型的属性
```python
from typing import Union,List,Set

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class User(BaseModel):
    name: str
    age: int = 0
    capacity: List[str]
class Item(BaseModel):
    # 一个列表里面存储多个User类型的数据
    user: List[User]


@app.put("/user/{user_id}")
async def update_item(user_id: int, item: Item):
    # 接收两个json结构体
    results = {"item_id": user_id, "item": item}
    return results

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app,host="0.0.0.0",port=8000)
```
请求
```shell
curl -X 'PUT' \
  'http://127.0.0.1:8000/user/0110' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "user": [
    {
      "name": "zhang san",
      "age": 20,
      "capacity": [
        "wirte code","eat"
      ]
    }
  ]
  "user": [
    {
      "name": "li si",
      "age": 24,
      "capacity": [
        "wirte code","eat","xuxu"
      ]
    }
  ]
}'
```
> 既然一个Class的字段可以嵌套另一个Class,所以只要有对应的Class,就可以无限的嵌套下去.

# cookie
存在问题!!!!
## 设置和查询cookie
```python
from fastapi import Cookie,FastAPI,responses,Request
from typing import Union

app = FastAPI()
'''
两种不同方式查询cookie
'''
@app.get("/user1/")
async def task(userid: Union[str,None] = Cookie(default=None)):
    return {"user id": userid}
@app.get("/user2/")
async def user2(request : Request):
    return request.cookies.get("cookie_name")
'''
设置cookie
'''
@app.get("/setcookie/")
async def setcookie(response: responses.RedirectResponse):
    return response.RedirectResponse(url="/", cookies={"cookie_name": "cookie_value"})

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app,host="0.0.0.0",port=8000)

```
